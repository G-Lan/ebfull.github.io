<script src="d3.v3.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<style>
.network {
  border: 1px solid #DEDEDE;
  display:block;
  margin:auto;
}

svg {
  margin: auto;
  display:block;
}

rect {
  fill: none;
  pointer-events: all;
}

circle {
	display:block;
}

line {
	display:block;
}

circle[cx=NaN] {
	display:none !important;
}

circle[cy=NaN] {
	display:none !important;
}

line[x1=NaN] {
	display:none !important;
}

line[y1=NaN] {
	display:none !important;
}

line[x2=NaN] {
	display:none !important;
}

line[y2=NaN] {
	display:none !important;
}


.node {
  fill: #000;
}

.link {
  stroke: #999;
}
</style>
<table>
<tr>
<td>
</td>
<td>
<div class="network">
</div>
</td>
<td>
<b>new blocks</b>
<div id="newblocklog" style="height: 500px; overflow: hidden">
</div>
</td>
<td bgcolor="gray">&nbsp;&nbsp;</td>
<td>
<div id="revenue" style="height: 500px; overflow: hidden">
</div>
</td>
</tr>
</table>
<br />
<span id='timenow'>0 seconds elapsed</span>
<br />
<a href="#" id="faster">faster</a> | <a href="#" id="slower">slower</a> | <a href="#" id="default">default</a> | <a href="#" id="stop">stop</a> | <a href="#" id="addnode">add node</a> | <a href="#" id="attack">node 0 selfish mine</a> | <a href="#" id="sybil">node 0 maxpeers 100</a>
<script>

function revchart(r, h) {
	var res = "<table><tr><td>node</td><td>revenue</td></tr>";
	// sort r
	var n = [];
	for (var id in r) {
		n.push({id:id,rev:r[id]})
	}
	n.sort(function(a,b) {
		if (a.rev == b.rev) return 0;

		return a.rev > b.rev ? -1 : 1;
	})
	for (var i=0;i<n.length;i++) {
		res += "<tr><td>" + n[i].id + "</td><td>" + n[i].rev + " (" + ((n[i].rev/h)*100).toFixed(2) + "%)<br /></td></tr>";
	}
	return res + "</table>";
}

// init with .network for network class div
function Visualizer(div) {
	this.divname = div;
}

Visualizer.prototype = {
	width: 1000,
	height: 500,
	linkDistance: 30,
	charge: -100,
	gravity: .5,
	nindex: 0, // the cursor of the nodes array

	svg: null,
	force: null,
	nodes: null,
	links: null,
	slink: null,
	snode: null,
	edges: {},
	inodes: [],
	updated:false,

	colormap:{},
	colormap_u:false,

	init: function() {
		// init the network layout/svg
		$(this.divname).css('width', this.width);
		$(this.divname).css('height', this.height);

		this.force = d3.layout.force()
			.size([this.width,this.height])
			.nodes([]) // no nodes
			.linkDistance(this.linkDistance)
			.charge(this.charge)
			.gravity(this.gravity);

		this.svg = d3.select(this.divname).append("svg")
	    	.attr("width", this.width)
	    	.attr("height", this.height);

	   	this.svg.append("rect")
		    .attr("width", this.width)
		    .attr("height", this.height);

		this.nodes = this.force.nodes();
		this.links = this.force.links();
		this.slink = this.svg.selectAll(".link");
		this.snode = this.svg.selectAll(".node");

		this.force = this.force.on("tick", this.tick());

		this.updated = true;
		this.rehash();
	},

	setColor: function(p, color) {
		this.colormap_u = true;
		this.colormap[p] = color;
	},

	getRandomLink: function() {
		var result;
		var count=1;
		for (var prop in this.edges) {
			if (Math.random() < 1/++count)
				result = prop;
		}
		if (!result)
			return -1;
		var e = result.split("-");
		return [parseInt(e[0]), parseInt(e[1])];
	},

	getRandomNode: function() {
		return this.inodes[Math.floor(Math.random()*this.inodes.length)];
	},

	getKeyForID: function(id) {
		return this.inodes.indexOf(id);
	},

	incCharge: function(amt) {
		this.force.charge(this.force.charge() - amt);
		this.updated = true;
		///////////this.rehash();
	},

	addNode: function() {
		// add a node, return the index
		this.nodes.push({id:"n"+this.nindex});
		this.inodes.push(this.nindex);
		this.updated = true;
		/////////////this.rehash();

		this.nindex++;
		return this.nindex-1;
	},

	connect: function(a, b) {
		if (this.edges.hasOwnProperty(a + '-' + b) || this.edges.hasOwnProperty(b + '-' + a))
			return false; // we're already connected

		if (a==b)
			return false; // can't connect to ourself silly!

		//console.log('CONNECTING EDGES ' + a + ' AND ' + b);
		this.edges[a + '-' + b] = {source:this.nodes[this.getKeyForID(a)],target:this.nodes[this.getKeyForID(b)]};
		this.links.push(this.edges[a + '-' + b]);

		this.updated = true;
		//////this.rehash();
	},

	disconnect: function(a, b) {
		if (!this.edges.hasOwnProperty(a + '-' + b) && !this.edges.hasOwnProperty(b + '-' + a))
			return false; // we're already disconnected

		var i = this.links.indexOf(this.edges[a + '-' + b]);
		if (i<0)
			i = this.links.indexOf(this.edges[b + '-' + a]);

		delete this.edges[a + '-' + b];
		delete this.edges[b + '-' + a];

		this.links.splice(i, 1); // remove the link

		this.updated = true;
		//////this.rehash();
	},

	removeNode: function(index) {
		// remove a node at index
		var i = this.getKeyForID(index);
		if (i < 0)
			return false; // this one has already been removed

		this.nodes.splice(i, 1);
		this.inodes.splice(i, 1);
		this.updated = true;
		///////////////////this.rehash();
	},

	tick: function() {
		var svg = this.svg;
		return function() {
			svg.selectAll(".link").attr("x1", function(d) { return d.source.x; })
				.attr("y1", function(d) { return d.source.y; })
				.attr("x2", function(d) { return d.target.x; })
				.attr("y2", function(d) { return d.target.y; });

			svg.selectAll(".node").attr("cx", function(d) { return d.x; })
				.attr("cy", function(d) { return d.y; });
		}
	},

	rehash: function() {
		/***** COLORMAP *****/
		if (this.colormap_u) {
			for (var p in this.colormap) {
				$(".n" + p).css('fill', this.colormap[p]);
			}
			this.colormap_u = false;
		}

		if (!this.updated)
			return;

		this.slink = this.slink.data(this.force.links(), function(d) { return d.source.id + "-" + d.target.id; });
		this.slink.enter().insert("line", ".node")
			.attr("class", "link");
		this.slink.exit().remove();

		this.snode = this.snode.data(this.force.nodes(), function(d) {return d.id;});
		this.snode.enter().append("circle").attr("class", function (d) {return "node " + d.id;})
			.attr("r", 3)
			.call(this.force.drag);
		this.snode.exit().remove();

		this.force.start();

		this.updated = false;
	}
};

// Array Remove - By John Resig (MIT Licensed)
Array.prototype.remove = function(from, to) {
  var rest = this.slice((to || from) + 1 || this.length);
  this.length = from < 0 ? this.length + from : from;
  return this.push.apply(this, rest);
};

function BinaryHeap(scoreFunction){
  this.content = [];
  this.scoreFunction = scoreFunction;
}

BinaryHeap.prototype = {
  push: function(element) {
    // Add the new element to the end of the array.
    this.content.push(element);
    // Allow it to bubble up.
    this.bubbleUp(this.content.length - 1);
  },

  pop: function() {
    // Store the first element so we can return it later.
    var result = this.content[0];
    // Get the element at the end of the array.
    var end = this.content.pop();
    // If there are any elements left, put the end element at the
    // start, and let it sink down.
    if (this.content.length > 0) {
      this.content[0] = end;
      this.sinkDown(0);
    }
    return result;
  },

  remove: function(node) {
    var length = this.content.length;
    // To remove a value, we must search through the array to find
    // it.
    for (var i = 0; i < length; i++) {
      if (this.content[i] != node) continue;
      // When it is found, the process seen in 'pop' is repeated
      // to fill up the hole.
      var end = this.content.pop();
      // If the element we popped was the one we needed to remove,
      // we're done.
      if (i == length - 1) break;
      // Otherwise, we replace the removed element with the popped
      // one, and allow it to float up or sink down as appropriate.
      this.content[i] = end;
      this.bubbleUp(i);
      this.sinkDown(i);
      break;
    }
  },

  size: function() {
    return this.content.length;
  },

  bubbleUp: function(n) {
    // Fetch the element that has to be moved.
    var element = this.content[n], score = this.scoreFunction(element);
    // When at 0, an element can not go up any further.
    while (n > 0) {
      // Compute the parent element's index, and fetch it.
      var parentN = Math.floor((n + 1) / 2) - 1,
      parent = this.content[parentN];
      // If the parent has a lesser score, things are in order and we
      // are done.
      if (score >= this.scoreFunction(parent))
        break;

      // Otherwise, swap the parent with the current element and
      // continue.
      this.content[parentN] = element;
      this.content[n] = parent;
      n = parentN;
    }
  },

  sinkDown: function(n) {
    // Look up the target element and its score.
    var length = this.content.length,
    element = this.content[n],
    elemScore = this.scoreFunction(element);

    while(true) {
      // Compute the indices of the child elements.
      var child2N = (n + 1) * 2, child1N = child2N - 1;
      // This is used to store the new position of the element,
      // if any.
      var swap = null;
      // If the first child exists (is inside the array)...
      if (child1N < length) {
        // Look it up and compute its score.
        var child1 = this.content[child1N],
        child1Score = this.scoreFunction(child1);
        // If the score is less than our element's, we need to swap.
        if (child1Score < elemScore)
          swap = child1N;
      }
      // Do the same checks for the other child.
      if (child2N < length) {
        var child2 = this.content[child2N],
        child2Score = this.scoreFunction(child2);
        if (child2Score < (swap == null ? elemScore : child1Score))
          swap = child2N;
      }

      // No need to swap further, we are done.
      if (swap == null) break;

      // Otherwise, swap and continue.
      this.content[n] = this.content[swap];
      this.content[swap] = element;
      n = swap;
    }
  }
};

// eventchain api, really just a toss up between a linked list
// structure for less common events and a binary heap for frequent
// ones. very accurate and simple (add and next are the only)
// supported operations
function EventChain() {
	this.heap = new BinaryHeap(function(x) {return x.time;})
	this.cache = false;
	this.quickhead = false;

	// add an event to a linked list
	this.quickadd = function(time, event) {
		var cur = this.quickhead;
		var prev = false;

		while(true) {
			if (!cur) {
				var struct = {time:time,event:event,next:false}

				if (prev)
					prev.next = struct;
				else
					this.quickhead = struct;

				break;
			} else if (cur.time > time) {
				var struct = {time:time,event:event,next:cur}

				if (prev)
					prev.next = struct;
				else
					this.quickhead = struct;

				break;
			}

			prev = cur;
			cur = cur.next;
		}
	}

	// used internally
	this.quicktime = function() {
		if (this.quickhead)
			return this.quickhead.time;
		else
			return Number.POSITIVE_INFINITY;
	}

	// used internally
	this.quickpop = function() {
		var ret = {time:this.quickhead.time,event:this.quickhead.event};
		this.quickhead = this.quickhead.next;
		return ret;
	}

	// add event to binary heap
	this.add = function(time, event) {
		if (this.cache && (time < this.cache.time)){
			this.heap.push(this.cache)
			this.cache = false;
		}

		this.heap.push({time:time,event:event})
	}

	// visit the next event unless the event occurs
	// on or after maxtime
	this.next = function(maxtime) {
		var ret;
		if (!this.cache)
			ret = this.heap.pop();
		else
			ret = this.cache;

		if (!ret || (ret.time > this.quicktime())) {
			if (ret) this.cache = ret;

			// quick goes first, if at all
			if (this.quicktime() < maxtime) {
				return this.quickpop();
			}

			return false;
		} else {
			if (ret.time >= maxtime) {
				this.cache = ret;
				return false;
			} else {
				this.cache = false;
				return ret;
			}
		}
	}
}

// the node's local state, or what it will know as "self"
function NodeState(node, network, id) {
	this.node = node;
	this.id = id;
	this.network = network;
	this.visualizerId = -1;
	this.mprob = 0;

	this.mine = function(p) {
		if (p === false) {
			this.mprob = 0;
		} else if (p === true) {
			network.mining.new(this);
		} else {
			this.mprob = p;
			if (network.mining.unreserved < p)
				return false;

			network.mining.unreserved -= p;
			this.startMining(); // start mining
		}

		return true;
	}

	this.onMined = function(self) {
		self.blockchain.mine(self.now());

		self.startMining();
	}

	this.startMining = function() {
		this.stopMining();
		if (this.mprob > 0) {
			this.prob("mining", 100, (this.mprob / this.blockchain.getstate().difficulty), this.onMined);
		}
		this.setColor(this.blockchain.getstate().color);
		this.peers.broadcast("status", this.blockchain.chainstate.get());
	}

	this.stopMining = function() {
		this.deprob("mining")
	}

	this.prob = function(label, delay, p, f) {
		this.network.pregister(label, delay, p, this.id, f)
	}

	this.deprob = function(label) {
		this.network.depregister(label, this.id)
	}

	this.setColor = function(color) {
		this.network.setColor(this.visualizerId, color);
	}

	// send another node in the network a message
	this.send = function(nid, name, obj) {
		// TODO: a cooler latency computation! maybe based on JSON.stringify size of obj too
		var delay = Math.floor(Math.random() * 5000) + 50;

		this.network.exec(new NodeMessageEvent(this.id, delay, nid, name, obj))
	}

	this.handle = function(from, name, obj) {
		if (typeof this.node._handlers[name] != "undefined") {
			this.node._handlers[name](this, from, obj)
		}
	}

	this.now = function() {
		return this.network.now;
	}

	this.peers = new PeerMgr(this);
	this.blockchain = new Blockchain(this);
}

// simple interface for an event that occurs in the simulation
function NodeEvent(delay, nid, f) {
	this.nid = nid;
	this.delay = delay;

	this.run = function(network) {
		f(network.nodes[this.nid]);
	}
}

// like NodeEvent, but used to call handler functions on nodes
function NodeMessageEvent(from, delay, nid, name, obj) {
	this.nid = nid;
	this.delay = delay;

	this.run = function(network) {
		network.nodes[this.nid].handle(from, name, obj) // tell the node to handle the message
	}
}

// like a NodeMessageEvent, except we create a new event after we run
function NodeTickEvent(delay, nid, f) {
	this.nid = nid;
	this.delay = delay;

	this.run = function(network) {
		if (f(network.nodes[this.nid]) !== false)
			network.exec(this) // register ourselves again!
	}
}

// like NodeTickEvent, but probabilistic
function NodeProbabilisticTickEvent(delay) {
	this.delay = delay;
	this.events = {}
	this.pnothing = 1;
	this.ptotal = 0;
	this.numevents = 0;

	this.register = function(p, nid, f) {
		// p is the probability of the event firing at the given moment

		this.events[nid] = {p:p, f:f}; // store the event
		this.pnothing *= 1-p; // the probability of nothing happening decreases
		this.ptotal += p;
		this.numevents++;
	}

	this.deregister = function(nid) {
		if (typeof this.events[nid] != "undefined") {
			this.pnothing /= 1-(this.events[nid].p);
			this.ptotal -= this.events[nid].p;
			delete this.events[nid];
			this.numevents--;
		}
	}

	this.runevent = function(network) {
		var which = Math.random() * this.ptotal;

		var cur = 0;
		for (var nid in this.events) {
			cur += this.events[nid].p;

			if (which <= cur) {
				this.events[nid].f(network.nodes[nid])
				break;
			}
		}
	}

	this.run = function(network) {
		var ecount = 0;

		while (Math.random() > this.pnothing) {
			ecount++;
		}

		while (ecount > 0) {
			// which event should occur?
			this.runevent(network)
			ecount--;
		}

		if (this.numevents) {
			network.quickexec(this); // register ourselves again! we still have events that could occur again
		}
	}
}

function MiningPool() {
	this.unreserved = 1;
	this.unreserved_pool = [];

	this.new = function(node) {
		this.unreserved_pool.push(node);
	}

	this.setup = function() {
		var m;
		var per = this.unreserved / this.unreserved_pool.length;

		for (var i=0;i<this.unreserved_pool.length;i++) {
			m = this.unreserved_pool[i];

			m.mprob = per;
			m.startMining();
		}
	}
}

function Network(visualizerDiv) {
	this.events = new EventChain(); // normal events
	this.mining = new MiningPool();
	this.pevents = {}; // probablistic event references
	this.visualizer = new Visualizer(visualizerDiv);
	if (typeof visualizerDiv != "undefined") {
		$(visualizerDiv).html();
		this.visualizer.init();
	}
	this.now = 0;

	this.nodes = [];
	this.nindex = 0;

	this.vars = {besth:-1,revenue:{},lastblocks:[]};

	// registers a probabilistic event
	this.pregister = function(label, delay, p, nid, cb) {
		//console.log("label: " + label + "; delay: " + delay + "; p: " + p + "; nid: " + nid + ";")
		if (typeof this.pevents[label] == "undefined") {
			this.pevents[label] = new NodeProbabilisticTickEvent(delay)
			this.quickexec(this.pevents[label])
		}
		
		this.pevents[label].register(p, nid, cb)
	}

	// deregisters a probablistic event
	this.depregister = function(label, nid) {
		if (typeof this.pevents[label] != "undefined") {
			this.pevents[label].deregister(nid)
		}
	}

	this.setColor = function(vid, color) {
		if (typeof visualizerDiv != "undefined") {
			this.visualizer.setColor(vid, color);
		}
	}

	// registers an event to occur, only use this for a few rare things
	this.quickexec = function(e) {
		this.events.quickadd(e.delay+this.now, e)
	}

	// registers an event to occur
	this.exec = function(e) {
		this.events.add(e.delay+this.now, e)
	}

	// connects two nodes in the visualizer
	this.connect = function (a, b) {
		if (typeof visualizerDiv != "undefined") {
			this.visualizer.connect(this.nodes[a].visualizerId, this.nodes[b].visualizerId);
		}
	}

	// disconnects two nodes in the visualizer
	this.disconnect = function (a, b) {
		if (typeof visualizerDiv != "undefined") {
			this.visualizer.disconnect(this.nodes[a].visualizerId, this.nodes[b].visualizerId);
		}
	}

	// adds amt node objects to the network simulator
	this.add = function(amt, node) {
		for (;amt>0;amt--) {
			var state = new NodeState(node, this, this.nindex);
			if (typeof visualizerDiv != "undefined")
				state.visualizerId = this.visualizer.addNode();
			node._init(state);
			for (var i=0;i<node._ticks.length;i++) {
				var t = node._ticks[i]
				this.exec(new NodeTickEvent(t.delay, this.nindex, t.f))
			}
			this.nodes[this.nindex] = state; // init and receive a state object back
			this.nindex++;
		}

		this.mining.setup();
	}

	// run buffer time worth of tasks
	this.run = function(buffer) {
		var max = this.now+buffer;
		var e = false;
		while (e = this.events.next(max)) {
			this.now = e.time;
			e.event.run(this)
		}

		this.now += buffer;

		var newblocklog = "";
		for (var i=0;i<this.vars.lastblocks.length;i++) {
			newblocklog = "<span style='color:white; background-color: " + this.vars.lastblocks[i].block.color + "'>node " + this.vars.lastblocks[i].node.id + " mined height " + this.vars.lastblocks[i].block.h + " (" + this.vars.lastblocks[i].block.transactions.length + " tx)<br /></span>" + newblocklog;
		}
		$("#newblocklog").html(newblocklog);

		$("#revenue").html(revchart(this.vars.revenue, this.vars.besth))

		if (typeof visualizerDiv != "undefined") {
			this.visualizer.rehash();
		}
	}
}

// the base node object just has a bunch of built in handlers
// with peermgr, and probably will have more built in things later
function Node() {
	this._init = function(self) {};
	this._handlers = {
		"connect":function(state, from, obj) {state.peers.event("connect", state, from, obj)},
		"accept":function(state, from, obj) {state.peers.event("accept", state, from, obj)},
		"reject":function(state, from, obj) {state.peers.event("reject", state, from, obj)},
		"disconnect":function(state, from, obj) {state.peers.event("disconnect", state, from, obj)},
		"getpeers":function(state, from, obj) {state.peers.event("getpeers", state, from, obj)},
		"peerlist":function(state, from, obj) {state.peers.event("peerlist", state, from, obj)},
		"status":function(state, from, obj) {
			if (state.peers.isConnected(from)) {
				if (state.blockchain.newstate(obj)) {
					state.startMining();
				}
			}
		}
	};
	this._ticks = [{delay: 1000, f: function(self) {
		return self.peers.tick();
	}}];

	this.init = function(callback) {
		this._init = callback;
	}

	// network events
	this.on = function(event, callback) {
		this._handlers[event] = callback;
	}

	this.tick = function(delay, callback) {
		this._ticks.push({delay: delay, f: callback})
	}
}

// will need to update this to interact with the messageevents somehow?
function PeerState(id, lastmessage) {
	this.id = id;
	this.lastmessage = lastmessage;
	this.active = false;
}

// PeerMgr for handling connections to other nodes.
function PeerMgr(node) {
	this.curpeers = 0;
	this.maxpeers = 8; // max number of peers we want
	this.peers = {}; // peer index
	this.nodearchive = [new PeerState(0, node.now())]; // seed with bootstrap node, archive of remote peers

	this.event = function(name, node, from, obj) {
		switch (name) {
			case "accept":
				if (typeof this.peers[from] != "undefined") {
					// remote node has accepted our connection request
					// remove them from our nodearchive
					for (var i=0;i<this.nodearchive.length;i++) {
						if (this.nodearchive[i].id == from) {
							this.nodearchive.remove(i);
						}
					}

					// set the connection as active
					this.peers[from].lastmessage = node.now();
					this.peers[from].active = true;

					// notify network of connection
					node.network.connect(node.id, from)
				}
			break;
			case "reject":
				// remote peer rejected our connect request
				if (typeof this.peers[from] != "undefined") {
					this.event("peerlist", node, from, obj) // get peerlist
					delete this.peers[from];
					this.curpeers -= 1;
				}
			break;
			case "connect":
				// remote node trying to connect to us
				// do we have enough peers already?
				if (Object.keys(this.peers).length < this.maxpeers) {
					// you can connect
					this.peers[from] = new PeerState(from, node.now());
					this.curpeers += 1;
					this.event("accept", node, from, obj);
					this.accept(from)
				} else {
					for (var k=0;k<this.nodearchive.length;k++) {
						if (this.nodearchive[k].id == from) {
							this.nodearchive.remove(k);
						}
					}

					this.nodearchive.unshift(new PeerState(from, node.now()))

					this.reject(from)
				}
			break;
			case "disconnect":
				// remote node disconnected
				if (typeof this.peers[from] != "undefined") {
					delete this.peers[from];
					this.curpeers -= 1;
					this.nodearchive.push(new PeerState(from, node.now()));

					// notify network of disconnection
					node.network.disconnect(node.id, from)
				}
			break;
			case "getpeers":
				// remote node wants peer list from us
				if (typeof this.peers[from] != "undefined") {
					this.sendpeers(from);
				}
			break;
			case "peerlist":
				if (typeof this.peers[from] != "undefined") {
					// add these peers to our nodearchive
					// if we don't have them already

					for (var i=0;i<obj.length;i++) {
						var candidate = obj[i];

						for (var k=0;k<this.nodearchive.length;k++) {
							if (this.nodearchive[k].id == candidate.id) {
								this.nodearchive.remove(k);
							}
						}

						this.nodearchive.unshift(new PeerState(candidate.id, node.now()))
					}
				}
			break;
		}
	}

	// find other peers
	this.tick = function() {
		if (node.now() > 500000)
			return false;

		//console.log(node.id + ": I have " + Object.keys(this.peers).length + " peers")
		if (this.curpeers < this.maxpeers) {
			// we need new peers
			// 1: getpeers to other peers
			// 2: connect to new peers in our nodearchive if there are any

			if (this.nodearchive.length) {
				var p = this.nodearchive.shift();
				this.nodearchive.push(p);

				if (typeof this.peers[p.id] == "undefined")
					this.connect(p)
			}

			if (Object.keys(this.peers).length) {
				var randomPeer = this.peers[Object.keys(this.peers)[Math.floor(Math.random() * Object.keys(this.peers).length)]]

				if (randomPeer.active) {
					this.getpeers(randomPeer.id)
				}
			}
		}
	}

	this.isConnected = function(p) {
		return (typeof this.peers[p] != "undefined") && this.peers[p].active
	}

	this.broadcast = function(name, obj) {
		// send the same message to all of our (active) peers
		for (var p in this.peers) {
			if (this.peers[p].active) {
				this.send(p, name, obj);
			}
		}
	}

	// why abstract this? i don't know yet.
	this.send = function(p, name, obj) {
		node.send(p, name, obj);
	}

	this.getpeers = function(p) {
		node.send(p, 'getpeers', {});
	}

	this.sendpeers = function(p, peers) {
		node.send(p, 'peerlist', this.nodearchive.slice(0, 15));
	}

	this.accept = function(p) {
		node.send(p, 'accept', {})
	}

	this.reject = function(p) {
		node.send(p, 'reject', this.nodearchive.slice(0, 15))
	}

	// send a connect message to a peer
	this.connect = function(p) {
		this.peers[p.id] = p;
		this.curpeers += 1;
		node.send(p.id, 'connect', {})
	}

	// send a disconnect message to a peer
	this.disconnect = function(id) {
		delete this.peers[p.id];
		this.curpeers -= 1;
		node.send(id, 'disconnect', {})
	}
}

// TODO: remove this crap
var cindex = 0;
var colors = ["red","green","blue","purple","orange","chartreuse","darkred","dodgerblue"]

function randomColor() {
	cindex++;

	return colors[cindex % colors.length]
}

/*
	Very simple (and broken) block object. Currently acts as a linked list to
	save memory.

	TODO: In the future 1 coinbase transaction per block, and it'll be used to store revenue/signature information.
*/
function Block(h, prev, time, credit) {
	if (h == 0) {
		this.id = "genesis";
		prev = false;
	} else {
		this.id = (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)); // just random data lol
	}

	this.h = h;
	this.prev = prev;
	this.color = randomColor();
	this.time = time;
	this.revenue = {};
	this.transactions = [];
	if (prev) {
		this.difficulty = prev.difficulty;
		this.signature = credit.id;
	}
	else {
		this.difficulty = 1000;
		this.signature = false;
	}

	if (this.h != 0) {
		credit.network.vars.lastblocks.push({node:credit,block:this})

		if (this.h > 50) {
			credit.network.vars.lastblocks.shift()
		}
	}

	this.report = function() {
		credit.network.vars.besth = this.h;
		credit.network.vars.revenue = this.revenue;
	}
}

/*
	TxIn object, has the same hash as the TxOut it references.
*/
function TxIn(prevtx, n) {
	// if prevtx is false, this is a coinbase input
	if (prevtx == false) {
		this.hash = (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1));
        this.prevtxid = "x";
        this.n = -1;
	} else {
		var prevout = prevtx.outputs[n];

		this.hash = prevout.hash;
		this.prevtxid = prevout.intxid;
		this.n = prevout.n;
		this.__prev = prevtx; // MEMORY MANAGEMENT PURPOSES, NODE MUST NOT USE THIS TO ITS ADVANTAGE!
	}
}

/*
	TxOut object, has the same hash as any TxIn that spends it.
*/
function TxOut(intx, n) {
	this.hash = (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1));
    this.intxid = intx.id;
    this.n = n;
    this.__in = intx;
}

/*
	Transaction object.

	TODO: make transaction constructor require outputs to be specified

	Currently just creates an arbitrary number of outputs. There is, obviously,
	no authentication or scripting.
*/
function Transaction(inputs) {
	this.id = (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)) + (Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1)); // just random data lol
    this.outputs = [];

    var no = Math.floor(Math.random() * 2) + 1;

    for (var i=0;i<no;i++) {
    	this.outputs.push(new TxOut(this, i));
    }

    this.inputs = inputs;
    this.coinbase = false;

    // returns a string representation of inputs lol in an array
    this.getInputs = function() {
    	return this.inputs.map(function(i) {return i.hash;});
    }

    // returns a string representation of outputs lol in an array
    this.getOutputs = function() {
    	return this.outputs.map(function(o) {return o.hash;});
    }
}

/*
	The unspent transaction output set object. This handles the transaction
	graph, tracks which transactions are committed to it, and quickly verifies
	new transactions.

	TODO: Refactor, lots of duplicate functionality occuring.
*/
function UTXO() {
	this.utxo = {};
	this.txmap = {};

	/*
		Sets a transaction's outputs as unspent.
	*/
	this.addoutputs = function(tx) {
		var out = tx.getOutputs();

		for (var i=0;i<out.length;i++) {
			this.utxo[out[i]] = tx.outputs[i];
		}
	}

	/*
		Adds a transaction to the UTXO set, setting its outputs as unspent
		and inputs as spent. Records that the transaction was committed in our
		committment map.
	*/
	this.add = function(tx) {
		if (typeof this.txmap[tx.id] != "undefined")
			return true; // already added

		if (this.verifyinputs(tx) != "valid")
			return false;

		this.spendinputs(tx);
		this.addoutputs(tx);

		this.txmap[tx.id] = true;
	}

	/*
		Removes a transaction from the UTXO set, should ONLY be done if the
		transaction's outputs are all unspent. Resets the transaction's inputs
		as unspent and removes the transaction from the committment map.

		TODO: Put extra checks in here to make sure it's working properly.
	*/
	this.remove = function(tx) {
		if (typeof this.txmap[tx.id] == "undefined")
			return true; // already deleted

		// remove this transaction's outputs from our UTXO set
		var txouts = tx.getOutputs();

		for (var i=0;i<txouts.length;i++) {
			if (typeof this.utxo[txouts[i]] == "undefined")
				console.log('fuck!! ' + JSON.stringify(tx))

			delete this.utxo[txouts[i]] // delete this output
		}

		// set the old inputs to spendable again
		var txins = tx.getInputs();

		for (var i=0;i<txins.length;i++) {
			var txin = tx.inputs[i];

			// set the old TxOut
			this.utxo[txins[i]] = txin.__prev.outputs[txin.n]
		}

		delete this.txmap[tx.id];
	}

	/*
		Spends the inputs of the transaction.
	*/
	this.spendinputs = function(tx) {
		if (tx.coinbase)
			return; // no inputs to spend

		var txins = tx.getInputs();

		for (var i=0;i<txins.length;i++) {
			if (typeof this.utxo[txins[i]] == "undefined")
				console.log('fuck ' + JSON.stringify(tx))

			delete this.utxo[txins[i]];
		}
	}

	/*
		Verifies a transaction's inputs.
			1. "missing" means one or more of the inputs references a transaction we have yet to see. Thus, this
			   transaction is an orphan transaction.
			2. "doublespend" means one or more of the inputs has already been spent. Could be because we're verifying
			   the same transaction twice for some reason.
			3. "valid" means what you think it does.
	*/
	this.verifyinputs = function(tx) {
		if (tx.coinbase)
			return "valid"; // coinbase transactions don't need valid inputs

		// this transactions' inputs must be in the UTXO set

		var txins = tx.getInputs();
		for (var i=0;i<txins.length;i++) {
			if (typeof(this.utxo[txins[i]]) == "undefined") {

				// we use the committment map as a txindex
				if (typeof this.txmap[tx.inputs[i].prevtxid] == "undefined") {
					return "missing";
				}

				return "doublespend";
			}
		}

		return "valid";
	}
}

/*
	MempoolTime is a (fun) experiment with tracking the "transactionseconds" that a transaction exists in the mempool for.

	When Blockchain sees two competing heights, it could select the one with the most transactionseconds. In an active environment
	of transactions, a selfish miner's pre-mined blocks would not have as many transactionseconds, and it would not succeed in
	orphaning an honest block from the chain, even during a sybil attack, due to the new relay behavior.

	See https://bitcointalk.org/index.php?topic=327064.0

	TODO: this is a pile of shit but it works
*/

function MempoolTime() {
	this.transactions = {}; // transactions being timed
	this.transactionsByH = {}; // transactions indexed by height entered into map
	this.transactionSeconds = {}; // transactionseconds per transaction indexed by txid

	this.get = function(txlist) {
		var sum = 0;

		for (var i=0;i<txlist.length;i++) {
			if (typeof this.transactionSeconds[txlist[i].id] != "undefined")
				sum += this.transactionSeconds[txlist[i].id];
		}

		return sum;
	}

	this.add = function(tx, h, now) {
		if (typeof this.transactions[tx.id] == "undefined") {
			this.transactions[tx.id] = now;

			if (typeof this.transactionsByH[h] == "undefined")
				this.transactionsByH[h] = [];

			this.transactionsByH[h].push(tx.id)
		}
	}

	this.confirm = function(tx, now) {
		if (typeof this.transactions[tx.id] != "undefined") {
			if (this.transactions[tx.id] !== true) {
				this.transactionSeconds[tx.id] = now - this.transactions[tx.id];
				this.transactions[tx.id] = true; // i don't remember why i'm doing this
			}
		}
	}

	// purge transactionseconds map of any old entries (h or below)
	this.purge = function(h) {
		for (var i in this.transactionsByH) {
			if (parseInt(i) <= h) {
				for (var j=0;j<this.transactionsByH[i].length;j++) {
					delete this.transactions[this.transactionsByH[i][j]]
					delete this.transactionSeconds[this.transactionsByH[i][j]]
				}

				delete this.transactionsByH[i];
			}
		}
	}
}

/*
	MapOrphans works (sort of) like bitcoin's mapOrphanTransactions and mapOrphanTransactionsByPrev.

	Simply a pool for storing orphan transactions which depend on transactions we haven't seen.

	TODO: Introduce maximum size, so when a new orphan transaction is added we can remove older ones.
*/
function MapOrphans() {
	this.transactions = {};
	this.transactionsByPrev = {};

	/*
		Add a transaction to the orphan pool, and track its inputs.
	*/
	this.add = function(tx) {
		if (typeof this.transactions[tx.id] != "undefined")
			return false;

		this.transactions[tx.id] = tx;

		var inputs = tx.getInputs(); // gets TxIn hashes

		for (var i=0;i<inputs.length;i++) {
			if (typeof this.transactionsByPrev[inputs[i]] == "undefined") {
				this.transactionsByPrev[inputs[i]] = [];
			}
			this.transactionsByPrev[inputs[i]].push(tx.id);
		}
	}

	/*
		Remove transaction from orphan pool, stop tracking its inputs.
	*/
	this.remove = function(tx) {
		if (typeof this.transactions[tx.id] == "undefined")
			return false;

		delete this.transactions[tx.id];

		var inputs = tx.getInputs(); // gets TxIn hashes

		for (var i=0;i<inputs.length;i++) {
			this.transactionsByPrev[inputs[i]].remove(this.transactionsByPrev[inputs[i]].indexOf(tx.id))

			if (this.transactionsByPrev[inputs[i]].length == 0) {
				delete this.transactionsByPrev[inputs[i]];
			}
		}
	}

	/*
		Iterate over all of the orphan transactions that attempt to spend a prevout.
		Uses a callback function.

		This is probably called by the mempool.

		Could be multiple calls, generally if the mempool finds good parent transactions the
		first one will be accepted and the others will fail before the callback.
	*/
	this.forprev = function(txin, cb) {
		if (typeof this.transactionsByPrev[txin] != "undefined") {
			var tmp = this.transactionsByPrev[txin].slice(0);

			for (var i=0;i<tmp.length;i++) {
				var txid = tmp[i]

				if (typeof this.transactions[txid] != "undefined")
					cb(this.transactions[txid])
			}
		}
	}
}

/*
	Mempool which tracks transactions which are ready to be placed in blocks.
*/
function Mempool() {
	this.transactions = [];
	this.spends = {};
	this.utxo = new UTXO();
	this.maporphans = new MapOrphans();

	/*
		New transaction we received over the wire.

		1. This transaction could have missing inputs. In which case, we will add it to
		   MapOrphans.
		2. This transaction could supply missing inputs. We will check MapOrphans for
		   transactions that depend on our inputs, and try to re-add them to the mempool.
        3. If we can add the transaction to our UTXO set, we can append the transaction
		   to a list of transactions in the mempool.
	*/
	this.add = function(tx) {
		var v = this.utxo.verifyinputs(tx);

		switch(v) {
			case "missing":
				// This transaction depends on inputs that aren't in the UTXO set.
				// Further, at least one transaction it depends on has not been seen by the
				// UTXO set. We will add this transaction to maporphans instead.

				this.maporphans.add(tx);
				return true;
			break;
			case "doublespend":
				// This transaction depends on inputs that aren't in the UTXO set, but
				// we've seen the transactions it references before. This implies it's a double-spend
				// so we should reject the transaction. (It could also be the same transaction sent twice.)

				return false;
			break;
			case "valid":
				// This transaction is valid, and we can add it to the UTXO set.
				this.utxo.add(tx);

				// We can remove this transaction from MapOrphans if it's there.
				this.maporphans.remove(tx);

				// Further, we will push the transaction to our mempool list.
				this.transactions.push(tx);

				// It is possible this transaction supplies inputs for orphaned transactions.
				// Iterate over all of this transaction's outputs and try to add orphaned
				// transactions again.
				var outputs = tx.getOutputs();

				var self = this;
				for (var i=0;i<outputs.length;i++) {
					this.maporphans.forprev(outputs[i], function(dtx) {
						self.add(dtx);
					})
				}

				// To resolve conflicts later when the UTXO set may be forcefully reverted due to a
				// block confirmation, we store 'spends' for inputs added to the mempool. These
				// spends are removed when the transaction is committed.
				var inputs = tx.getInputs();

				for (var i=0;i<inputs.length;i++) {
					this.spends[inputs[i]] = tx;
				}

				return true;
			break;
		}
	}

	/*
		A transaction was 'confirmed' in a block in our chainstate. This means it MUST be
		committed to our UTXO set.

		This commitment _could_ conflict with previous spends committed to the UTXO set,
		which have not been confirmed yet. We will iterate the spends for all of this
		transaction's inputs, and remove transactions recursively as necessary.

		Remove all spend entries and commit the transaction to UTXO.

		Finally, remove the transaction from the mempool.
	*/
	this.confirm = function(tx) {
		// Iterate over our inputs and remove any conflicting transactions from the UTXO.

		var inputs = tx.getInputs();

		for (var i=0;i<inputs.length;i++) {
			if (typeof this.spends[inputs[i]] != "undefined") {
				// If this input was spent by a transaction other than us, let's remove it recursively.

				if (this.spends[inputs[i]].id != tx.id) {
					this.remove(this.spends[inputs[i]])
				}
			}

			// Remove this spend as we're committing the transaction.
			delete this.spends[inputs[i]];
		}

		// Commit to UTXO if it hasn't been already.
		this.utxo.add(tx);

		// Remove from mempool list (if it's there).
		var itx = this.transactions.indexOf(tx);
		if (itx >= 0) {
			this.transactions.remove(itx);
		}
	}

	/*
		Remove a transaction from the UTXO set. It's possible that this transaction's outputs
		are already spent by other transactions, in which case we will need to remove those as well.

		This function acts recursively to remove a transaction from the UTXO.
	*/
	this.remove = function(tx) {
		var outputs = tx.getOutputs();

		for (var i=0;i<outputs.length;i++) {
			if (typeof this.spends[outputs[i]] != "undefined") {
				this.remove(this.spends[outputs[i]])

				// Nothing spends this output anymore.
				delete this.spends[outputs[i]];
			}
		}

		// Remove from UTXO set.
		this.utxo.remove(tx);
	}

	/*
		A transaction is no longer confirmed, probably due to a rollback in the chainstate.

		In this situation, the transaction will remain in our UTXO set, but its spends will be re-added
		to the spend map, and it will be placed in the mempool again.
	*/
	this.unconfirm = function(tx) {
		var inputs = tx.getInputs();

		for (var i=0;i<inputs.length;i++) {
			this.spends[inputs[i]] = tx;
		}

		this.transactions.push(tx);
	}

	/*
		Returns our mempool for block creation.
	*/
	this.get = function() {
		return this.transactions.slice(0);
	}
}

/*
	Genesis block contains 5 'coinbase' transactions with broken inputs that are ignored by UTXO during verification.
*/
var GenesisBlock = new Block(0, false, 0);
GenesisBlock.transactions = [
	new Transaction([new TxIn( false )])
];
GenesisBlock.transactions.map(function(tx) {
	tx.coinbase = true;
	return tx;
})

/*
	Chainstate handles changes to the blockchain from a node's perspective.

	* performs reorganizations of blockchain
	* handles new transactions
*/
function Chainstate(starthead, node) {
	this.head = false;
	this.mempool = new Mempool();
	this.mempooltime = new MempoolTime();
	this.transactionseconds = 0;

	this.get = function() {
		return this.head;
	}

	/*
		Get the transaction from our index.

		TODO: figure out what we're doing for indexing per node, etc.
	*/
	this.gettx = function(txid) {
		return this.mempool.utxo.txmap[txid];
	}

	/*
		Have we seen this tx?
	*/
	this.seentx = function(txid) {
		return typeof(this.mempool.utxo.txmap[txid]) != "undefined"
	}

	/*
		Called whenever we receive a new transaction over the wire.

		TODO: Remove rejects map and use inventory system instead.
	*/
	this.newtx = function(tx) {
		// we received a new tx over the network or something, should we add to mempool?

		if (!this.mempool.add(tx)) {
			return false;
		} else {
			// added to the mempool
			
			// experiment:
			this.mempooltime.add(tx, this.head.h, node.now())

			return true;
		}
	}

	/*
		Reverses the head of the blockchain by undoing all of the constituent transactions.

		Notifies the mempool of the changes for each transaction in reverse order of commitment.
	*/
	this.reverse = function() {
		for (var i=this.head.transactions.length-1;i>=0;i--) {
			this.mempool.unconfirm(this.head.transactions[i])
		}

		this.head = this.head.prev;
	}

	/*
		Moves the head forward to b, by playing the transactions to the mempool.

		b is the new head.
	*/
	this.forward = function(b) {
		for (var i=0;i<b.transactions.length;i++) {
			this.mempool.confirm(b.transactions[i])
			this.mempooltime.confirm(b.transactions[i], node.now())
		}

		this.head = b;
	}

	/*
		Sets the chainstate to the block, requires finding the common ancestor between the head
		and the new block, reversing and forwarding the head as needed to reflect changes
		to the UTXO set and remove conflicts from the mempool.
	*/
	this.set = function(block) {
		var newcur = block.prev;

		var numorphan = 0;
		var forwards = [block];

		if (this.head == block)
			return numorphan; // we're already set to this... :\

		while (true) {
			if (this.head == newcur) {
				while(true) {
					// loop through our forward blocks
					if (forwards.length > 0) {
						this.forward(forwards.pop());
					} else {
						break;
					}
				}
				break;
			} else if (this.head.h > newcur.h) {
				this.reverse();
				numorphan++;
			} else if (newcur.h > this.head.h) {
				forwards.push(newcur);
				newcur = newcur.prev;
			} else {
				this.reverse();
				numorphan++;

				forwards.push(newcur);
				newcur = newcur.prev;
			}
		}

		this.transactionseconds = this.mempooltime.get(this.head.transactions) // get the transactionseconds for the final set block

		this.mempooltime.purge(this.head.h - 10) // purge old mempooltime entries :)

		// this.rejects = {}; // reset rejects
		// TODO: we need a full-blown inventory system still

		return numorphan;
	}

	// unroll our head until we reach the given height
	// return the block at that height
	// used for selfish mining attack
	this.unroll = function(h) {
		var cur = this.head;

		while (cur.h != h) {
			cur = cur.prev;
		}

		return cur;
	}




	/*
		Initialization of the chainstate using the seed block.
	*/
	this.forward(starthead);
}

/*
	Blockchain object handles interactions between new transactions, mining, blocks
	and other events from the perspective of the miner. Also handles difficulty changes.
*/
function Blockchain(node) {
	this.chainstate = new Chainstate(GenesisBlock, node);

	this.attacker_status = false; // selfish mining attack
	this.private_chainstate = new Chainstate(this.chainstate.get(), node);

	this.target_avg_between_blocks = 2.5 * 60 * 1000; // target time between blocks
	this.difficulty_adjustment_period = 2016;

	/*
		Get the transaction from our index.

		TODO: inventory system how many times do i have to
	*/
	this.gettx = function(txid) {
		return this.chainstate.gettx(txid);
	}

	/*
		Have we seen this transaction?
	*/
	this.seentx = function(txid) {
		return this.chainstate.seentx(txid);
	}

	/*
		New transaction received over the wire, hand it to our chainstate(s).
	*/
	this.newtx = function(tx) {
		if (this.attacker_status)
			this.private_chainstate.newtx(tx); // add to private chainstate if possible

		return this.chainstate.newtx(tx);
	}

	/*
		New block received over the wire.

		TODO: Merge this into the inventory system somehow, because this assumes instant
		communication of the entire branch.
	*/
	this.newstate = function(b) {
		if (!this.attacker_status)
			return this._newstate(b);

		var r;
		if (r = this._newstate(b)) {
			// is the new block larger than our private chain?
			if (b.h > this.private_chainstate.get().h) {
				// give up. adopt the new (public) chainstate
				this.private_chainstate.set(this.chainstate.get());
			} else {
				if (b.h == this.private_chainstate.get().h) {
					this.chainstate.set(this.private_chainstate.get()); // publish private chainstate
				} else {
					this.chainstate.set(this.private_chainstate.unroll(b.h+1))
				}
			}
		}

		return r;
	}

	/*
		The real newstate handler. Performs a simple height change.

		TODO: Centralize block comparison and use work instead of height like bitcoin does.
	*/
	this._newstate = function(b) {
		// is this new block larger than ours?
		if (b.h > this.chainstate.get().h) {
			this.chainstate.set(b);

			if (!this.attacker_status)
				this.private_chainstate.set(b);

			return true;
		}
/*
		// if they're the same height, should we orphan our current head
		// use mempooltime to figure it out!
		if (b.h == this.chainstate.get().h) {
			// experiment:
			// does this new block have more transactionseconds?
			if (this.chainstate.mempooltime.get(b.transactions) > this.chainstate.transactionseconds) {
				this.chainstate.set(b);

				if (!this.attacker_status)
					this.private_chainstate.set(b);

				return true;
			}
		}
*/

		return false;
	}

	/*
		Triggered whenever a new block is mined, we retroactively determine how we were acting
		before the block was mined by us.
	*/
	this.mine = function(now) {
		if (this.attacker_status) {
			// always mine on the private chain

			var newb = new Block(this.private_chainstate.get().h+1, this.private_chainstate.get(), now, node);
			this.diff_adjust(newb);
			newb.transactions = this.private_chainstate.mempool.get();

			this.private_chainstate.set(newb);
		} else {
			// always mine on the public chain

			var newb = new Block(this.chainstate.get().h+1, this.chainstate.get(), now, node);
			this.diff_adjust(newb);
			newb.transactions = this.chainstate.mempool.get();

			this.chainstate.set(newb);
		}
	}

	/*
		Difficulty adjustment algorithm, similar to bitcoin. Also used to condense revenues for reporting.
	*/
	this.diff_adjust = function(b) {
		if (!(b.h % this.difficulty_adjustment_period)) {
			// this is a difficulty adjustment block

			var total = 0;
			var last = b.time;
			var cur = b.prev;
			for (var i=0;i<this.difficulty_adjustment_period;i++) {
				total += last - cur.time;
				last = cur.time;
				cur = cur.prev;
			}
			var avg = total / this.difficulty_adjustment_period;

			// how much should we change the difficulty by?
			var old = b.difficulty;
			b.difficulty *= this.target_avg_between_blocks / avg; // 10 minutes?

			console.log("(height = " + b.h + ") Difficulty adjustment: from " + old + " to " + b.difficulty + " (" + (this.target_avg_between_blocks / avg) + "x)")

			// awesome, now since we're an adjustment block we can go fetch the revenue from the last diff block and perform a merge
			var newrev = {};

			cur = b;

			while( (cur.h == b.h) || cur.h % this.difficulty_adjustment_period) {
				if (cur.signature !== false) {
					if (typeof newrev[cur.signature] == 'undefined') {
						newrev[cur.signature] = 0;
					}
					newrev[cur.signature] += 1;
				}

				cur = cur.prev;
			}

			// cur should now be a diff adjustment block
			for (var s in cur.revenue) {
				if (typeof newrev[s] == 'undefined') {
					newrev[s] = 0;
				}
				newrev[s] += cur.revenue[s];
			}

			b.revenue = newrev;

			b.report();
		}
	}

	/*
		Used to get the _real_ chainstate from the perspective of the node, for reporting purposes.
	*/
	this.getstate = function() {
		if (this.attacker_status)
			return this.private_chainstate.get();

		return this.chainstate.get();
	}
}

var nodes = 200;

var btc = new Node();

// btc.init() - an initialization function (post peermgr)
// btc.tick() - a tick which occurs routinely
// btc.on() - attaching new events

function s4() {
  return Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1);
};

function guid() {
  return s4() + s4() + s4();
}


btc.init(function(self) {
	switch(self.id) {
		case 0:
			self.mine(0.31)
		break;
		case 1:
			self.mine(0.22)
		break;
		case 2:
			self.mine(0.13)
		break;
		case 3:
			self.mine(0.06)
		break;
		case 4:
			self.mine(0.05)
		break;
		case 5:
			self.mine(0.03)
		break;
		case 6:
			self.mine(0.02)
		break;
		case 7:
			self.mine(0.02)
		break;
		default:
			if (self.id < 100)
				self.mine(true);
			else
				self.mine(false);
		break;
	}

	self.getqueue = new EventChain();
	self.mapAlreadyAskedFor = {};
	self.mapAskFor = {};

	// node will randomly generate a new transaction
	self.prob("newtx", 1000, 0.0005, function() {
		// get a random unspent output and just create a transaction with it

		
		var r = self.blockchain.chainstate.mempool.utxo.utxo[
			Object.keys(self.blockchain.chainstate.mempool.utxo.utxo)[Math.floor(Math.random() * Object.keys(self.blockchain.chainstate.mempool.utxo.utxo).length)]
		];

		var newtx = new Transaction([new TxIn(r.__in, r.n)]);

		self.handle(-1, "tx", newtx);
	})
})

btc.on("tx", function(self, from, obj) {
	if (self.blockchain.newtx(obj)) {
		// transaction entered the mempool, announce INV to all peers
		self.peers.broadcast("inv", obj)
	}

	// we should also clear mapAlreadyAskedFor/mapAskFor
	for (var f in self.mapAlreadyAskedFor) {
		delete self.mapAlreadyAskedFor[f][obj.id]
	}

	delete self.mapAskFor[obj.id]
})

btc.on("inv", function(self, from, obj) {
	// from has a (transaction) object, do we have it?
	if (!self.blockchain.seentx(obj.id)) {
		// we haven't seen it yet!

		// this means we need to queue for the node to send us the data
		self.getqueue.add(self.now(), {from:from,obj:obj})
	}
})

btc.on("getdata", function(self, from, obj) {
	if (!self.blockchain.seentx(obj.id)) {
		// why are they asking us, we don't have this
	} else {
		// send tx data back
		self.send(from, "tx", obj)
	}
})

btc.tick(100, function(self) {
	// every 100msec we simulate bitcoind's "SendMessages"

	var e;
	while (e = self.getqueue.next(self.now())) {
		e = e.event;

		// did we get it from another peer already?
		if (self.blockchain.seentx(e.obj.id))
			continue; // next event please

		// did we already try getdata recently for this txid?
		// recently = 10 seconds no tx response
		if (typeof self.mapAskFor[e.obj.id] == "undefined") {
			self.mapAskFor[e.obj.id] = self.now() + (10 * 1000);
		} else {
			if (self.mapAskFor[e.obj.id] > self.now()) {
				self.getqueue.add(self.mapAskFor[e.obj.id], e)
				continue; // next event please
			} else {
				self.mapAskFor[e.obj.id] = self.now() + (10 * 1000);
			}
		}

		// did we already try getdata recently for this txid FROM THIS NODE
		// recently = 2 minutes
		if (typeof self.mapAlreadyAskedFor[e.from] == "undefined") {
			self.mapAlreadyAskedFor[e.from] = {};
		}

		if (typeof self.mapAlreadyAskedFor[e.from][e.obj.id] == "undefined") {
			self.mapAlreadyAskedFor[e.from][e.obj.id] = self.now() + (2 * 60 * 1000); // we can getdata this again in 2 minutes
		} else {
			if (self.mapAlreadyAskedFor[e.from][e.obj.id] > self.now()) {
				// requeue this event for that time
				self.getqueue.add(self.mapAlreadyAskedFor[e.from][e.obj.id], e)
				continue; // next event please
			} else {
				self.mapAlreadyAskedFor[e.from][e.obj.id] = self.now() + (2 * 60 * 1000); // we can getdata this again in 2 minutes
			}
		}

		// if we've made it this far, we can request getdata from the other node
		self.send(e.from, "getdata", e.obj)
	}
})

var net = new Network();

net.add(nodes, btc);

var interval = 10;

setInterval(function() {
	net.run(interval);
	$("#timenow").html((net.now/1000) + " seconds elapsed");
}, 10)

$('#faster').click(function() {
	interval *= 2;
})

$('#slower').click(function() {
	interval /= 2;
})

$('#default').click(function() {
	interval = 10;
})

$("#stop").click(function() {
	interval = 0;
})

$("#addnode").click(function() {
	net.add(1, btc);
})

$("#attack").click(function() {
	net.nodes[0].blockchain.attacker_status = true;
})

$("#sybil").click(function() {
	net.nodes[0].peers.maxpeers = 100;
})

</script>