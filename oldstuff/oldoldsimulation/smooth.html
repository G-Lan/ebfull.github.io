<head>
<meta charset="utf-8">
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="lib.js"></script>
<script src="node.js"></script>
<style>
.network {
  border: 1px solid #DEDEDE;
  display:block;
  margin:auto;
}

svg {
  margin: auto;
  display:block;
}

rect {
  fill: none;
  pointer-events: all;
}

circle {
	display:block;
}

line {
	display:block;
}

circle[cx=NaN] {
	display:none !important;
}

circle[cy=NaN] {
	display:none !important;
}

line[x1=NaN] {
	display:none !important;
}

line[y1=NaN] {
	display:none !important;
}

line[x2=NaN] {
	display:none !important;
}

line[y2=NaN] {
	display:none !important;
}

.node {
  fill: #000;
}

.link {
  stroke: #999;
}
</style>
</head>
<body>
<div class="network">
</div>
<script>

var Nodes = {
	network:null,
	nodes:{},
	nindex: 0,
	tindex: 50,
	runlock:false,
	con:0,
	queue:[],
	active:false,

	init:function() {
		this.network.init();
	},

	/*
	message is from fromid (-1 for local sleeps)
	message is to toid
	message is delayed by delay
	message is directed to name method
	message is obj
	*/
	run:function(fromid, toid, delay, name, obj) {
		//console.log('RUN (' + fromid + ' => ' + toid + ') ' + name + ': ' + JSON.stringify(obj));

		if (this.runlock)
			return;

		// we need to calculate the latency from fromid to toid
		// for now let's just randomly choose somewhere between 50 and 120ms
		// on each message
		var latency = delay;

		if (fromid != -1)
			latency += Math.floor(Math.random() * 500) + 100;

		// later we can make this more consistent
		// later we can make this buffered
		// later we can make this depend on the object size

		if (!this.nodes.hasOwnProperty(toid))
			return false;

		if (!this.nodes[toid].actor.hasOwnProperty(name))
			return false; // do we need to overload this

		if (this.nodes[toid].actor.lock && name != 'deconstruct')
			return false; // locked! no more messages

		var parent = this;

		var perform = function(){
			var e = function() {
				//console.log('EXECUTING ' + name + ' (' + fromid + ' => ' + toid + ')');
				if (parent.nodes.hasOwnProperty(toid))
					parent.nodes[toid].actor[name](fromid, obj);
			}

			// is another task running?
			if (parent.active) {
				console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! QUEUED SOMETHING');
				parent.queue.push(e)
			} else {
				parent.active = true;
				// is something in the queue?
				// should be executed before us
				while (func = parent.queue.pop()) {
					console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! escaped race condition')
					func();
				}

				e();

				parent.active = false;
			}
		};

		window.setTimeout(perform, latency);
	},

	get:function(id) {
		return this.nodes[id];
	},

	setColor: function(id, color) {
		$(".n" + this.get(id).networkid).css('fill', color);
	},

	connect: function(a, b) {
		// only write to graph if both nodes agree to connection
		if (this.get(a).actor.peers.exists(b) && this.get(b).actor.peers.exists(a))
			this.network.connect(this.get(a).networkid, this.get(b).networkid);
		else {
			//console.log('deferring graph write');
		}
	},

	disconnect: function(a, b) {
		this.network.disconnect(this.get(a).networkid, this.get(b).networkid);
	},

	add:function() {
		var n = this.network.addNode();
		var parent = this;

		this.nodes[this.nindex] =
			{
				networkid:n,
				actor:new Node(this.nindex, parent),
			};
		this.run(-1, this.nindex, 100, 'tick', {});
		this.nindex++;
		return this.nindex-1;
	},

	remove:function(id) {
		this.get(id).actor.lock = true;
		this.run(-1, id, 0, 'deconstruct', {});
	}
};

Nodes.network = {
	width: 1000,
	height: 500,
	linkDistance: 30,
	charge: -100,
	gravity: .5,
	nindex: 0, // the cursor of the nodes array

	svg: null,
	force: null,
	nodes: null,
	links: null,
	slink: null,
	snode: null,
	edges: {},
	inodes: [],
	updated:false,

	init: function() {
		// init the network layout/svg
		$('.network').css('width', this.width);
		$('.network').css('height', this.height);

		this.force = d3.layout.force()
			.size([this.width,this.height])
			.nodes([]) // no nodes
			.linkDistance(this.linkDistance)
			.charge(this.charge)
			.gravity(this.gravity);

		this.svg = d3.select(".network").append("svg")
	    	.attr("width", this.width)
	    	.attr("height", this.height);

	   	this.svg.append("rect")
		    .attr("width", this.width)
		    .attr("height", this.height);

		this.nodes = this.force.nodes();
		this.links = this.force.links();
		this.slink = this.svg.selectAll(".link");
		this.snode = this.svg.selectAll(".node");

		this.force = this.force.on("tick", this.tick());

		this.updated = true;
		this.rehash();
	},

	getRandomLink: function() {
		var result;
		var count=1;
		for (var prop in this.edges) {
			if (Math.random() < 1/++count)
				result = prop;
		}
		if (!result)
			return -1;
		var e = result.split("-");
		return [parseInt(e[0]), parseInt(e[1])];
	},

	getRandomNode: function() {
		return this.inodes[Math.floor(Math.random()*this.inodes.length)];
	},

	getKeyForID: function(id) {
		return this.inodes.indexOf(id);
	},

	incCharge: function(amt) {
		this.force.charge(this.force.charge() - amt);
		this.updated = true;
		///////////this.rehash();
	},

	addNode: function() {
		// add a node, return the index
		this.nodes.push({id:"n"+this.nindex});
		this.inodes.push(this.nindex);
		this.updated = true;
		/////////////this.rehash();

		this.nindex++;
		return this.nindex-1;
	},

	connect: function(a, b) {
		if (this.edges.hasOwnProperty(a + '-' + b) || this.edges.hasOwnProperty(b + '-' + a))
			return false; // we're already connected

		if (a==b)
			return false; // can't connect to ourself silly!

		console.log('CONNECTING EDGES ' + a + ' AND ' + b);
		this.edges[a + '-' + b] = {source:this.nodes[this.getKeyForID(a)],target:this.nodes[this.getKeyForID(b)]};
		this.links.push(this.edges[a + '-' + b]);

		this.updated = true;
		////////////this.rehash();
	},

	disconnect: function(a, b) {
		if (!this.edges.hasOwnProperty(a + '-' + b) && !this.edges.hasOwnProperty(b + '-' + a))
			return false; // we're already disconnected

		var i = this.links.indexOf(this.edges[a + '-' + b]);
		if (i<0)
			i = this.links.indexOf(this.edges[b + '-' + a]);

		delete this.edges[a + '-' + b];
		delete this.edges[b + '-' + a];

		this.links.splice(i, 1); // remove the link

		this.updated = true;
		//////////////////this.rehash();
	},

	removeNode: function(index) {
		// remove a node at index
		var i = this.getKeyForID(index);
		if (i < 0)
			return false; // this one has already been removed

		this.nodes.splice(i, 1);
		this.inodes.splice(i, 1);
		this.updated = true;
		///////////////////this.rehash();
	},

	tick: function() {
		var svg = this.svg;
		return function() {
			svg.selectAll(".link").attr("x1", function(d) { return d.source.x; })
				.attr("y1", function(d) { return d.source.y; })
				.attr("x2", function(d) { return d.target.x; })
				.attr("y2", function(d) { return d.target.y; });

			svg.selectAll(".node").attr("cx", function(d) { return d.x; })
				.attr("cy", function(d) { return d.y; });
		}
	},

	rehash: function() {
		if (!this.updated)
			return;

		this.slink = this.slink.data(this.force.links(), function(d) { return d.source.id + "-" + d.target.id; });
		this.slink.enter().insert("line", ".node")
			.attr("class", "link");
		this.slink.exit().remove();

		this.snode = this.snode.data(this.force.nodes(), function(d) {return d.id;});
		this.snode.enter().append("circle").attr("class", function (d) {return "node " + d.id;})
			.attr("r", 3)
			.call(this.force.drag);
		this.snode.exit().remove();

		this.force.start();

		this.updated = false;
	}
};

$(document).ready(function() {
	Nodes.init();

	$("#create").click(function() {
		for (var i=0;i<50;i++) {
			Nodes.add();
		}
	});

	$("#create").click();

	$("#stop").click(function() {
		Nodes.runlock = true;
	});

	setInterval(function() {
		Nodes.network.rehash();
	}, 10);
});
</script>

<p><a id="create" href="#">add a node</a> <a id="stop" href="#">stop everything</a> </p>

</body>