var searchIndex = {};
searchIndex['nemo'] = {"items":[[0,"","nemo","Nemo provides session type abstractions for asynchronous networking\nprotocols. It can be used to build high performance, memory safe\nand type-safe protocol implementations.",null,null],[3,"Chan","","Channels are provided to handlers to act as a \"courier\" for the session type\nand a guard for the IO backend.",null,null],[3,"Defer","","Handlers must return `Defer` to indicate to the `Session` how to proceed in\nthe future. `Defer` can be obtained by calling `.defer()` on the channel, or\nby calling `.close()` when the session is `Eps`.",null,null],[3,"Session","","`Session`s are containers of channels which store the current session type\ninternally through a function pointer to a concrete handler.",null,null],[0,"peano","","Peano numbers are natural numbers expressed as successions of zero.\nWe use them in our API to provide \"nested\" protocol escaping, as\nyou must indicate the number of layers you wish to escape from.",null,null],[3,"Z","nemo::peano","Peano numbers: Zero",null,null],[3,"S","","Peano numbers: Increment",null,null],[8,"Peano","","Represents a peano number.",null,null],[8,"Pop","","This represents the types obtained by popping N layers from\na stack.",null,null],[16,"Head","","",0,null],[16,"Tail","","",0,null],[0,"session_types","nemo","Session types encode the current state of a communication channel. It is\nnot possible to change to another state without following the protocol.",null,null],[3,"Accept","nemo::session_types","Accept either `P` or something in `Q`.",null,null],[3,"Choose","","Choose from `P` or something in `Q`.",null,null],[3,"Finally","","Finally choose `P`.",null,null],[3,"Eps","","The session is at the end of communication.\nThe channel can now be gracefully closed.",null,null],[3,"Send","","The session expects to send `T` and proceed to session `S`.",null,null],[3,"Recv","","The session expects to receive `T` and proceed to session `S`.",null,null],[3,"Nest","","Protocols ocassionally do not follow a linear path of behavior. It may\nbe necessary to return to a previous \"state\" in the protocol. However,\nthis cannot be expressed in the typesystem, because the type will fold\nover itself infinitely. Instead, `Nest<S>` and `Escape<N>` are provided.\nThese types allow you to \"break\" out of a nested scope in the protocol\nby an arbitrary number of layers `N`.",null,null],[3,"Escape","","Escape from a nested scope by an arbitrary number of layers `N`, using\npeano numbers.",null,null],[11,"num","","",1,{"inputs":[{"name":"choose"}],"output":{"name":"u8"}}],[11,"num","","",2,{"inputs":[{"name":"finally"}],"output":{"name":"u8"}}],[11,"num","","",1,{"inputs":[{"name":"choose"}],"output":{"name":"u8"}}],[8,"Chooser","","",null,null],[10,"num","","",3,{"inputs":[{"name":"chooser"}],"output":{"name":"u8"}}],[8,"Acceptor","","This trait effectively posits that a protocol which handles `T` must\nadditionally handle other types. If `T` is an `Accept<P, Q>` the\nprotocol must handle `P` *and* be an `Acceptor` of `Q`. If `T` is \na `Finally<P>` it must handle `P`.",null,null],[10,"defer","","",4,{"inputs":[{"name":"acceptor"},{"name":"u8"}],"output":{"name":"defer"}}],[8,"SessionType","","All session types have duality. Two clients that communicate will\nalways have a session type that is the dual of their counterpart.",null,null],[16,"Dual","","",5,null],[0,"channels","nemo","",null,null],[3,"Blocking","nemo::channels","This is an implementation of a blocking channel IO backend. Internally\nit uses MPSC queues.",null,null],[11,"new","","Create a new bi-directional channel for protocols.",6,null],[11,"send","","",6,{"inputs":[{"name":"blocking"},{"name":"t"}],"output":null}],[11,"recv","","",6,{"inputs":[{"name":"blocking"}],"output":{"name":"option"}}],[11,"close","","",6,{"inputs":[{"name":"blocking"}],"output":null}],[11,"new","nemo","Create a new session initialized to the Protocol.",7,{"inputs":[{"name":"session"}],"output":{"name":"session"}}],[11,"new_dual","","Create a new session initialized to the dual of the Protocol.",7,{"inputs":[{"name":"session"}],"output":{"name":"session"}}],[11,"with","","Operates the handler, returning false if the channel closed. This will panic\nif the channel was closed in a previous call.",7,{"inputs":[{"name":"session"},{"name":"i"}],"output":{"name":"bool"}}],[11,"defer","","Defer the rest of the protocol execution. Useful for returning early.",8,{"inputs":[{"name":"chan"}],"output":{"name":"defer"}}],[11,"close","","Close the channel. Only possible if it's in `Eps` (epsilon) state.",8,{"inputs":[{"name":"chan"}],"output":{"name":"defer"}}],[11,"send","","Send an `A` to IO.",8,{"inputs":[{"name":"chan"},{"name":"a"}],"output":{"name":"chan"}}],[11,"recv","","Receive an `A` from IO.",8,{"inputs":[{"name":"chan"}],"output":{"name":"result"}}],[11,"enter","","Enter into a nested protocol.",8,{"inputs":[{"name":"chan"}],"output":{"name":"chan"}}],[11,"pop","","Escape from a nested protocol.",8,{"inputs":[{"name":"chan"}],"output":{"name":"chan"}}],[11,"choose","","Select a protocol to advance to.",8,{"inputs":[{"name":"chan"}],"output":{"name":"chan"}}],[11,"accept","","Accept one of many protocols and advance to its handler.",8,{"inputs":[{"name":"chan"}],"output":{"name":"defer"}}],[8,"Protocol","","A `Protocol` describes the underlying protocol, including the \"initial\" session\ntype. `Handler`s are defined over concrete `Protocol`s to implement the behavior\nof a protocol in a given `SessionType`.",null,null],[16,"Initial","","",9,null],[8,"Handler","","`Handler` is implemented on `Protocol` for every session type you expect to defer,\nincluding the initial state.",null,null],[10,"with","","Given a channel in a particular state, with a particular environment,\ndo whatever you'd like with the channel and return `Defer`, which you\ncan obtain by doing `.defer()` on the channel or `.close()` on the\nchannel.",10,{"inputs":[{"name":"handler"},{"name":"chan"}],"output":{"name":"defer"}}],[8,"IO","","This trait describes a backend for a channel to expose a message\npassing interface.",null,null],[10,"send","","Sends an object from the handler to the outside channel.",11,{"inputs":[{"name":"io"},{"name":"t"}],"output":null}],[10,"recv","","Attempts to retrieve an object from the outside channel. This *can* block\nbut it also might not, depending on the impl.",11,{"inputs":[{"name":"io"}],"output":{"name":"option"}}],[10,"close","","Closes the channel.",11,{"inputs":[{"name":"io"}],"output":null}]],"paths":[[8,"Pop"],[3,"Choose"],[3,"Finally"],[8,"Chooser"],[8,"Acceptor"],[8,"SessionType"],[3,"Blocking"],[3,"Session"],[3,"Chan"],[8,"Protocol"],[8,"Handler"],[8,"IO"]]};
initSearch(searchIndex);
